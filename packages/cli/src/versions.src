var L=(p=>(p.KEY_ADD="ka",p.KEY_DELETE="kd",p.DEPLOY_ADD="da",p.DEPLOY_DELETE="dd",p))(L||{}),i=(d=>(d.Deploy="Deploy",d.GetLatestVersion="GetLatestVersion",d.AddAuthorizedKey="AddAuthorizedKey",d.GetVersionUrl="GetVersionUrl",d.ListVersions="ListVersions",d))(i||{}),n=(e=>(e.Windows="win",e.Linux_FlatPak="flatpak",e.Linux_Snap="snap",e.Linux_Dev="deb",e.Linux_Rpm="rpm",e.Linux_Pacman="pacman",e.Linux_AppImage="appimage",e.Linux_Apk="apk",e.Apple_IOS="ios",e.Apple_OSX="osx",e.Android="android",e))(n||{});var t=()=>Math.floor(new Date().getTime()/1e3);var y=class{versions={};allowedKeys={};constructor(s){this.versions=s.versions,this.allowedKeys=s.allowedKeys}initialize(s,e){if(Object.keys(this.allowedKeys).length>0)throw new Error("this contract can be initialized only once");let t2=t();this.allowedKeys[s]={},typeof this.allowedKeys[e]>"u"&&(this.allowedKeys[e]={}),this.allowedKeys[s][L.KEY_ADD]=t2,this.allowedKeys[s][L.KEY_DELETE]=t2,this.allowedKeys[e][L.DEPLOY_ADD]=t2,this.allowedKeys[e][L.DEPLOY_DELETE]=t2}isKeyAllowed(s,e){return typeof this.allowedKeys[s]<"u"&&typeof this.allowedKeys[s][e]<"u"}deploy(s,e,t2,o){if(this.isKeyAllowed(s,L.DEPLOY_ADD)){if(typeof this.versions[e]>"u"&&(this.versions[e]={}),typeof this.versions[e][t2]<"u")throw new Error(`version '${t2}' has already been deployed on the platform '${e}'`);this.versions[e][t2]={url:o,timestamp:t()}}else throw new Error(`key '${s}' is not allowed to add deployments`)}removeDeploy(s,e,t2){if(this.isKeyAllowed(s,L.DEPLOY_DELETE))if(this.versions[e]&&this.versions[e][t2])delete this.versions[e][t2];else throw new Error(`version '${t2}' doesn't exist on the platform '${e}'`);else throw new Error(`key '${s}' is not allowed to delete deployments`)}removeKeyRole(s,e,t2){if(this.isKeyAllowed(s,L.KEY_DELETE))if(this.allowedKeys[e]&&this.allowedKeys[e][t2])delete this.allowedKeys[e][t2];else throw new Error(`key '${e}' is not defined for role ${t2}`);else throw new Error(`key '${s}' is not allowed to remove Keys`)}addKeyRole(s,e,t2){if(this.isKeyAllowed(s,L.KEY_ADD)){if(this.allowedKeys[e]){if(this.allowedKeys[e][t2])return}else this.allowedKeys[e]={};this.allowedKeys[e][t2]=t()}else throw new Error(`key '${s}' is not allowed to remove Keys`)}getLatestVersion(s){let e=this.listVersions(s);if(e.length>0)return e[e.length-1];throw new Error(`No version available for '${s}': versions = ${JSON.stringify(this.versions)}`)}getVersionUrl(s,e){if(this.versions[s]){if(this.versions[s][e])return this.versions[s][e].url;throw new Error(`Version '${e}' on Platform '${s}' hasn't been deployed`)}throw new Error(`Platform '${s}' hasn't been deployed`)}listVersions(s){if(this.versions[s]){let e=Object.keys(this.versions[s]).map(t2=>({version:t2,url:this.versions[s][t2].url,timestamp:this.versions[s][t2].timestamp}));return e.sort((t2,o)=>t2.timestamp<o.timestamp?-1:1),e}return[]}toJSON(){return{versions:this.versions,allowedKeys:this.allowedKeys}}};export function handle(state,action){let cl=new y(state);try{switch(action.input.function){case i.Deploy:{let{version,url,platform}=action.input.args;return cl.deploy(action.caller,platform,version,url),{state:cl.toJSON()}}case i.GetLatestVersion:{let{platform}=action.input.args;return{result:cl.getLatestVersion(platform)}}case i.AddAuthorizedKey:{let{pubKey,permission}=action.input.args;return cl.addKeyRole(action.caller,pubKey,permission),{state:cl.toJSON()}}case i.GetVersionUrl:{let{version,platform}=action.input.args;return{result:cl.getVersionUrl(platform,version)}}case i.ListVersions:{let{platform}=action.input.args;return{result:cl.listVersions(platform)}}}}catch(e){throw new ContractError(e)}throw new Error(`unknown function call: '${action.input.function}'`)};
